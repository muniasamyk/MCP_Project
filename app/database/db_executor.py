import psycopg2
from psycopg2 import pool
from contextlib import contextmanager
from app.core.config import settings
from app.utils.logger import get_logger

logger = get_logger(__name__)

# Global connection pool - initializes on first use
_db_pool = None

def get_db_pool():
    global _db_pool
    if _db_pool is None:
        try:
            logger.info("Initializing DB connection pool...")
            _db_pool = psycopg2.pool.ThreadedConnectionPool(
                minconn=1,
                maxconn=20, # Should be enough for this POC
                host=settings.DB_HOST,
                port=settings.DB_PORT,
                user=settings.DB_USER,
                password=settings.DB_PASSWORD,
                dbname=settings.DB_NAME
            )
        except Exception as e:
            logger.error(f"DB Connection failed: {e}")
            raise ConnectionError(f"Could not connect to database: {e}")
            
    return _db_pool

@contextmanager
def get_db_connection():
    pool = get_db_pool()
    conn = pool.getconn()
    try:
        yield conn
    finally:
        pool.putconn(conn)

# --- Raw SQL Execution (Text-to-SQL Support) ---

def execute_raw_sql(query: str, params: tuple = None):
    """
    Executes a raw SQL query generated by the LLM.
    SAFETY: Strictly restricts execution to SELECT statements only.
    Supports parameterized queries to prevent SQL injection.
    """
    clean_query = query.strip().lower()
    
    # Strictly forbid anything that isn't a SELECT
    if not clean_query.startswith("select"):
        logger.warning(f"Blocked unsafe query: {query}")
        return [{"error": "Security Alert: Only SELECT queries are allowed."}]
        
    try:
        with get_db_connection() as conn:
            with conn.cursor() as cursor:
                logger.info(f"Executing SQL: {query} | Params: {params}")
                cursor.execute(query, params)
                
                # Fetch column names to return structured data
                if cursor.description:
                    columns = [desc[0] for desc in cursor.description]
                    rows = cursor.fetchall()
                    
                    results = []
                    for row in rows:
                        results.append(dict(zip(columns, row)))
                    
                    logger.info(f"Query returned {len(rows)} rows")
                    return results
                else:
                    return []
    except Exception as e:
        logger.error(f"SQL Execution Error: {e}")
        return [{"error": f"Database Error: {str(e)}"}]

# --- Legacy Helper Functions (kept for backward compatibility) ---

def fetch_employees_by_department(department):
    return execute_raw_sql(
        "SELECT id, name, email, department, salary FROM employees WHERE LOWER(department) = LOWER(%s)",
        (department,)
    )

def fetch_projects_by_status(status):
    return execute_raw_sql(
        "SELECT id, name, description, status, start_date, end_date, budget FROM projects WHERE LOWER(status) = LOWER(%s)",
        (status,)
    )

def fetch_issues_by_priority(priority):
    return execute_raw_sql(
        "SELECT id, title, description, priority, status, assigned_to FROM issues WHERE LOWER(priority) = LOWER(%s)",
        (priority,)
    )
